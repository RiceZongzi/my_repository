[TOC]

# 概述

## 数据结构概念

- 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

## 分类

### 逻辑结构分类

- 集合结构
  - 集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。
- 线性结构
  - 线性结构中的数据元素之间存在一对一的关系。
- 树形结构
  - 树形结构中的数据元素之间存在一对多的层次关系。
- 图形结构
  - 图形结构的数据元素是多对多的关系。

### 物理结构分类

- 顺序存储结构
  - 把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的。
  - 比如数组。
- 链式存储结构
  - 是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。

## 算法的概念

- 指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略
  机制。
- 优秀的算法追求以下两个目标
  - 花最少的时间完成需求；
  - 占用最少的内存空间完成需求；

# 算法分析

## 时间复杂度

### 事后分析方法

```Java
public void method() {
    long start = System.currentTimeMillis();
    // 算法语句
    long end = System.currentTimeMillis();
    System.out.println(end - start);
}
```

### 事前分析方法

- 算法采用的策略和方案；
- 编译产生的代码质量；
- 问题的输入规模(所谓的问题输入规模就是输入量的多少)；
- 机器执行指令的速度；

### 大O记法

#### 概念
- 在进行算法分析时，语句总的执行次数`T(n)`是关于问题规模`n`的函数，进而分析`T(n)`随着`n`的变化情况并确定`T(n)`的量级。算法的时间复杂度，就是算法的时间量度，记作:
$$
  T(n)=O(f(n))
$$
  它表示随着问题规模`n`的增大，算法执行时间的增长率和`f(n)`的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中`f(n)`是问题规模`n`的某个函数。在这里，我们需要明确一个事情：
$$
  执行次数 = 执行时间
$$
- 用大写`O()`来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模`n`的增大，`T(n)`增长最慢的算法为最优算法。

- 使用规则
  - 用常数1取代运行时间中的所有加法常数；
  - 在修改后的运行次数中，只保留高阶项；
  - 如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数。
  
#### 常见的大O阶


| 描述         | 增长的数量级 | 说明     | 举例           |
| ------------ | ------------ | -------- | -------------- |
| 常数级别     | 1            | 普通语句 | 将两个数相加   |
| 对数级别     | logn         | 二分策略 | 二分查找       |
| 线性级别     | n            | 循环     | 找出最大元素   |
| 线型对数级别 | nlogn        | 分治思想 | 归并排序       |
| 平方级别     | n^2          | 双层循环 | 检查所有元素对 |
| 立方级别     | n^3          | 三层循环 | 检查所有三元组 |
| 指数级别     | 2^n          | 穷举查找 | 检查所有子集   |

他们的复杂程度从低到高依次为：
$$
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)
$$
#### 最坏情况
- 最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非
特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。

## 空间复杂度

### Java中常见内存占用

#### 基本数据类型占用

| 数据类型 | 内存占用字节数 |
| :------: | :------------: |
|   byte   |       1        |
|  short   |       2        |
|   int    |       4        |
|   long   |       8        |
|  float   |       4        |
|  double  |       8        |
| boolean  |       1        |
|   char   |       2        |

#### 计算机访问内存方式

- 一次一个字节

#### 变量占用

- 一个引用（机器地址）需要8个字节表示

  - 比如

  - ```Java
      Date date = new Date();
    ```

  - 中，date这个变量需要占用8个字节来表示

#### 对象占用

- 每个对象的自身开销是16个字节，用来保存对象的头信息

  - 不包含对象内部存储的数据占用的内存

  - 比如

  - ```Java
      Date date = new Date();
    ```

  - 中，new Date()需要16个字节保存对象的头信息

#### 一般内存的使用

- 如果不够8个字节，都会被自动填充为8字节

#### 数组

- Java中数组被被限定为对象，因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。

### 算法的空间复杂度

- 算法的空间复杂度计算公式记作：
$$
S(n)=O(f(n))
$$
  其中n为输入规模，f(n)为语句关于n所占存储空间的函数。

## 总结

- 由于`Java`中有内存垃圾回收机制，并且`JVM`对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一个Java程序的内存占用情况，但是了解了`Java`的基本内存占用，使我们可以对`Java`程序的内存占用情况进行估算。
- 由于现在的计算机设备内存一般都比较大，内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。
- 但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几`kb`，这个时候对算法的空间复杂度就有要求了。

# 排序

## 一些概念

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
- **内排序**：所有排序操作都在内存中完成；
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

## 复杂度

|          | 时间复杂度  | 空间复杂度 | 排序方式  | 稳定性 |
| :------: | :---------: | :--------: | :-------: | :----: |
| 冒泡排序 |   O(n^2)    |    O(1)    | In-place  |   Y    |
| 选择排序 |   O(n^2)    |    O(1)    | In-place  |   N    |
| 插入排序 |   O(n^2)    |    O(1)    | In-place  |   Y    |
| 希尔排序 | O(n log2 n) |    O(1)    | In-place  |   N    |
| 归并排序 |  O(n lg n)  |    O(n)    | Out-place |   Y    |
| 快速排序 |   O(n^2)    |  O(lg n)   | In-place  |   N    |
|  堆排序  |  O(n lg n)  |    O(1)    | In-place  |   N    |
| 计数排序 |  O(n  + k)  |    O(k)    | Out-place |   Y    |
|  桶排序  |   O(n^2)    |  O(n + k)  | Out-place |   Y    |
| 基数排序 |  O(n  * k)  |  O(n + k)  | Out-place |   Y    |

- **n**：数据规模
- **k**：“桶”的个数
- **In-place**：占用常数内存，不占用额外内存
- **Out-place**：占用额外内存

## 比较和非比较的区别

- 常见的**快速排序、归并排序、堆排序、冒泡排序**等属于**比较排序**。
  - 在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。
  - 比较排序适用于一切需要排序的情况。
- **计数排序、基数排序、桶排序**则属于**非比较排序**。
  - 非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。
  - 非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

## 常见排序

### 

# 线性表

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

## 一些概念

- 前驱元素：若A元素在B元素的前面，则称A为B的前驱元素
- 后继元素：若B元素在A元素的后面，则称B为A的后继元素
- 特征：
  - 第一个数据元素没有前驱，这个数据元素被称为头结点；
  2. 最后一个数据元素没有后继，这个数据元素被称为尾结点；
  3. 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。

## 分类

### 顺序表

> 顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。

#### 时间复杂度

- **get(i)：**不难看出，不论数据元素量`n`有多大，只需要一次`eles[i]`就可以获取到对应的元素，所以时间复杂度为`O(1)`;
- **insert(int i,T t)：**每一次插入，都需要把`i`位置后面的元素移动一次，随着元素数量`n`的增大，移动的元素也越多，时间复杂为`O(n)`;
- **remove(int i)：**每一次删除，都需要把`i`位置后面的元素移动一次，随着数据量n的增大,移动的元素也越多，时间复杂度为`O(n)`;
- 由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显。

#### 应用

- ```java
  java.util.ArrayList
  ```

### 链表

> 链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，结点可以在运行时动态生成。

#### 单向链表

- 单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成
  - 数据域用来存储数据
  - 指针域用来指向其后继结点
- 链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。
- (null, next) -> (data, next) -> (data, next) -> (data, null)

#### 双向链表

- 双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成
  - 数据域用来存储数据
  - 一个指针域用来指向其后继结点
  - 另一个指针域用来指向前驱结点。
- 链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。
- (null, null, next) -> (pre, data, next) -> (pre, data, next) -> (pre, data, null)

##### 应用

- ```java
  java.util.LinkedList
  ```

#### 时间复杂度

- **get(int i)：**每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素`n`的增多，比较的元素越多，时间复杂度为`O(n)`
- **insert(int i, T t)：**每一次插入，需要先找到`i`位置的前一个元素，然后完成插入操作，随着数据元素`n`的增多，查找的元素越多，时间复杂度为`O(n)`;
- **remove(int i)：**每一次移除，需要先找到`i`位置的前一个元素，然后完成插入操作，随着数据元素`n`的增多，查找的元素越多，时间复杂度为`O(n)`
- 相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作，同时它并没有涉及的元素的交换。
- 相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。

### 栈

> 栈是一种基于先进后出(`FILO`)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

- 数据进入到栈的动作为**压栈**
- 数据从栈中出去的动作为**弹栈**
